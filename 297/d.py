import math
A,B = map(int, input().split())
# print(math.gcd(A,B))
if A ==B:#もしAとBが同じ値なら
    print(0)
    exit()
cnt = 0
#以降A≠Bについて
while A != B:
    #Aのほうが大きいようにしたいので、
    if A < B:#もしAよりもBが大きかったら
        A,B = B,A#AとBを入れ替える
    
    if A%B == 0:#もしAがBの倍数なら
        cnt+= A//B-1#変遷した数字の数-1=変遷した回数
        print(cnt)
        exit()
    else:#AがBの倍数ではないなら
        cnt += A//B#AがBよりも小さな値になるまで変遷させる
        A = A%B#新しいAがの値
"""
D - Count Subtractions
https://atcoder.jp/contests/abc297/tasks/abc297_d
入力
A,B : 正の整数
まずはじめにA==Bのときは答えは0です。以降はA≠Bのときについてです。

今回愚直にwhile文でやるとTLEします。なので、どうにかして高速化をする必要があります。
そこで、A,Bが最終的にどのような数になるかを考えます。
ex1) 3, 8
→3, 5
→3, 2
→1, 2
→1, 1

ex1) 3, 9
→3, 6
→3, 3
上記2つの例から、A,Bは最大公約数に帰着しそうです。
なぜなら、
AとBに共通する約数(Z)がある場合、abs(A-B)も必ずZを約数に持つためです。
ex2)
27と9の最大公約数9
27-9 = 18 18は9を約数に持つ(18は9の倍数である)

このことから、A,Bともに最大公約数に変遷するまでの操作回数を求めることで問題を解くことが可能です。

1,
(A>Bとする)変遷する回数は
AがBの倍数の時(A%B == 0)は、A/B-1
A/Bは元の数字から変遷した数字の個数(27→18→9,3)
-1 は矢印の回数(3-1=2)
で求められ、
2
AがBの倍数ではないとき((A%B != 0)は
AがBよりも小さな値になるまでBで引き続けま
その場合の操作回数(cnt)はA//Bです
(cnt == A//BよりB x cnt >= Aなので)
Aの値が更新されたら、もう一度1か2の処理に戻ります

上記の操作を繰り返すことで、高速にA==Bとなる回数を求めることができます

"""
