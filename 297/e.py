# N,K = map(int, input().split())
# A = list(map(int, input().split()))
# A.sort(reverse=True)#商品の値段を大きいもの順に並べる
# # 上記操作はなくても大丈夫なはずだが、理解しやすくするために並べ替えた

# dp = [[0]* (K+1) for i in range(N)]#N+(K+1)のdpを作成

# for j in range(1,K+1):#商品2のみを使用したK番目までの支払い方法
#     dp[0][j] = A[0]*j

# for i in range(1,N):
#     is_flg = 0#次参照する商品iまでを使用した支払い方法
#     was_flg = 1#参照する商品i-1までを使用した支払い方法
#     for j in range(1,K+1):
#         if dp[i][is_flg]+A[i] == dp[i-1][was_flg]:
#             #商品iを買って、i-1番目までのj番目の支払いの金額と同じ担った場合
#             dp[i][j] = dp[i][is_flg]+A[i]#どちらの値を使用してもよい
#             is_flg += 1#次参照する商品iまでを使用した支払い方法を更新
#             was_flg += 1#次参照する商品i-1までを使用した支払い方法を更新
#         elif dp[i][is_flg]+A[i] < dp[i-1][was_flg]:#商品iを買ったら、i-1番目までのj番目の支払いよりも小さい時
#             dp[i][j] = dp[i][is_flg]+A[i]
#             #商品iまで使用して支払うj番目の支払い=商品iまでを支払うパターンにおいてis_flg番目に安い支払いの値+i番目の商品の値
#             is_flg += 1#次参照する商品iまでを使用した支払い方法のみを更新
#         elif dp[i][is_flg] +A[i]> dp[i-1][was_flg]:#商品iを買ったら、i-1番目までのj番目の支払いよりも大きい時
#             dp[i][j] = dp[i-1][was_flg]
#             #商品iまで使用して支払うj番目の支払い=商品i-1までを支払うパターンにおいてwas_flg番目に安い支払いの値
#             was_flg += 1#次参照する商品i-1までを使用した支払い方法のみを更新

# print(dp[-1][K])

"""
E - Kth Takoyaki Set
https://atcoder.jp/contests/abc297/tasks/abc297_e

入力
N:たこ焼きの種類
K:何番目に安い支払いを出力するべきか？
A[i]:i番目のたこ焼きの値段

結論から書きますと、今回動的計画法(dp)を用いて解く問題です。(制約からN*Kのdpぽいなって思いました)
なぜなら、i番目の商品を買うか買わないか(買った場合i番目に安い支払いに影響がでるか出ないか)は、
i-1番目までの買い物の結果と、i番目の商品を何個買うかの2つの要素のみで決まるからです。
ex)
4 6
20 25 30 100
のとき

商品1しかない場合、
支払いのパターンは
20,40,60,80,100,120
となる

商品2もある場合
商品1の支払い方法
20,40,60,80,100,120と25を使って
20,25,40,45(20+25),50(25+25),60となる

商品3もある場合
商品2までの最適な支払い方法
20,25,40,50,60,65と30を使って・・・
とこれまで支払った値と現在の商品の値だけを用いることでK番目に最小の支払い方法がわかります

そのため、縦軸に商品の数、横軸に支払いのパターンを取り、動的計画法をすることで答えにたどり着けます。
"""
