"""
https://atcoder.jp/contests/abc324/tasks/abc324_c
C - Error Correction 

問題文 
高橋君は英小文字からなる文字列 T を青木君に向けて送りました。その結果、青木君は英小文字からなる文字列 T ′ を受信しました。 T ′ は T から一部が変更されてしまっている可能性があり、具体的には、下記の 4 つのうちのちょうど 1 つが成り立つことがわかっています。 T ′ は、 T と等しい。 T ′ は、 T のいずれか 1 つの位置（先頭と末尾も含む）に英小文字を 1 つ挿入して得られる文字列である。 T ′ は、 T からある 1 文字を削除して得られる文字列である。 T ′ は、 T のある 1 文字を別の英小文字に変更して得られる文字列である。 青木君が受信した文字列 T ′ と、英小文字からなる N 個の文字列 S 1 ​ ,S 2 ​ ,…,S N ​ が入力として与えられるので、 S 1 ​ ,S 2 ​ ,…,S N ​ のうち、高橋君が送った文字列 T と等しい可能性があるものをすべて求めてください
"""

N,T = input().split()
N = int(N)
ans = []

for i in range(N):
    T_dash = input()
    if len(T_dash) == len(T):
        if T_dash == T:#1
            # print(T_dash,i+1)
            ans.append(i+1)

        else:
            diff_count = sum([s != t for s, t in zip(T_dash, T)])
            if diff_count == 1:
                # print(T_dash,i+1)
                ans.append(i+1)


    elif len(T_dash) - len(T) == 1:
            if T_dash[:-1] == T:
                ans.append(i+1)
                continue

            for j in range(len(T)):
                if T_dash[j] != T[j]:
                    if T_dash[j+1:] == T[j:]:
                        ans.append(i+1)
                    break
    elif len(T) -len(T_dash) == 1:
            
            if T[:-1] == T_dash:
                ans.append(i+1)
                continue
            
            for j in range(len(T_dash)):
                if T[j] != T_dash[j]:
                    if T[j+1:] == T_dash[j:]:
                        ans.append(i+1)
                    break

print(len(ans))
ans.sort()
print(*ans, sep=" ")


"""
T'  は  T と完全に一致している、
もしくは   T'  は  T に1文字を挿入したもの、
もしくは   T'  は  T から1文字を削除したもの、
もしくは   T'  は  T から1文字を別の文字に変更したもの

ここで注目したいのは
1,4の条件はT'の文字数とTの文字数が同じであり、
2はT'の方が一文字少なく、
3はT'の方が一文字多いということです。

そのため、入力T'の文字数でどの条件に当てはまるかわかります。ここからはそれぞれの条件について当てはまるかについて考えます。


### コード解説の続き

#### 条件1: \( T' \) は \( T \) と完全に一致している
この条件は最も単純で、単純に2つの文字列が等しいかどうかを確認します。Pythonでは`if T_dash == T:`と記述することで、2つの文字列が等しいかどうかを確認できます。

#### 条件4: \( T' \) は \( T \) から1文字を別の文字に変更したもの
この条件も比較的シンプルで、2つの文字列の各位置を比較し、異なる文字が1つだけ存在するかどうかを確認します。`zip`関数を用いて2つの文字列を同時にループさせ、異なる文字の数をカウントします。異なる文字が1つだけの場合、この条件を満たします。

#### 条件2: \( T' \) は \( T \) に1文字を挿入したもの
ケース1: T′ の最後の文字が追加された文字である場合。この場合、if T_dash[:-1] == T:でチェックします。T_dash[:-1]は、最後の1文字を除いた文字列を表します。 
ケース2: T′ の途中に文字が追加されている場合。この場合、追加された文字の位置を特定し、その文字を除いた残りの部分が Tと一致するかを確認します。コード内のfor j in range(len(T)):ループがこのチェックを行っています。ループ変数jは、チェックする文字の位置を表します。if T_dash[j] != T[j]:で、 T ′ とTで文字が異なる位置を見つけ、if T_dash[j+1:] == T[j:]:で、その位置以降の文字が一致しているかを確認します。

#### 条件3: \( T' \) は \( T \) から1文字を削除したもの
この条件も条件2と似ていますが、今回は\( T \)の各位置で1文字を削除し、残りの部分が\( T' \)と一致するかどうかを確認します。

### コードの詳細
コードは基本的に上記の各条件を順番に確認し、条件を満たす場合には`ans`リストにそのインデックスを追加しています。最終的に`ans`リストの長さ（条件を満たす\( T' \)の数）と、`ans`リストをソートして出力します。

### まとめ
この問題では、与えられた文字列\( T \)に対して、4つの条件を満たす文字列\( T' \)を見つけることが求められています。各条件を確認するロジックを実装し、条件を満たす場合にはそのインデックスを記録しています。最後に、条件を満たす文字列の数と、それらのインデックスを出力しています。このようなロジックにより、与えられた問題を効率的に解くことができます。

"""