C = []
H,W = map(int, input().split())

for i in range(H):
    a = input()
    C.append(a)
N = min(H,W)
ans = [0]*(N+1)

for i in range(1,H-1):#+-探索する
    for j in range(1,W-1):
        if C[i][j] == "#" and C[i+1][j+1] == "#" and C[i+1][j-1] == "#" and C[i-1][j+1] == "#" and C[i-1][j-1] == "#":
            for k in range(N):
                if i+k >= H or i-k<0 or j+k>=W or j-k<0:
                    ans[k-1] += 1
                    break
                
                if C[i+k][j+k] == "#" and C[i-k][j+k] == "#" and C[i+k][j-k] == "#"  and C[i-k][j-k] == "#":
                    continue
                else:
                    ans[k-1] += 1
                    break
            
print(*ans[1:],sep=" ")

"""
今回a,bの取りうる範囲は0-indexの場合、
a:1~H-2
b:1~W-2
です。なぜならa,bが端なら2つ目の条件を満たすことができないためです。

そのため、今回探索するべき範囲は()a,bが#の所をまず探索し、そこから条件2,3について考えていきます。

伸ばしていく枝について
今回C[a][b]を中心として、右上、右下、左上、左下に枝を伸ばせるかについて検討していきます。
枝の最大の長さは、C[a][b]がグリッドの中心のときで、min(H,W)//2に制約されます。
そのため、すべてのグリッドについて探索O(H*W)し、#であった点から枝の長さを探索O(min(H,W)//2)しても十分間に合います。

手順
すべてのグリッドO(H*W)に対して探索し、そのグリッドが「#でかつ端でない」のであれば、枝を伸ばしていきます。
枝の長さO(min(H,W)//2)で、探索した4つの枝先すべてが「範囲内かつ#」であれば枝を伸ばしていき、そうでなければそのグリッドでの探索を終え、枝の長さをカウントします。

"""