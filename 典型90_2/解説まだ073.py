"""
https://takeg.hatenadiary.jp/entry/2021/12/03/113718
https://atcoder.jp/contests/typical90/submissions/45709841
https://www.youtube.com/watch?v=woK8jwuc3z0&t=551s

木DP
"""
import sys
sys.setrecursionlimit(10**8)
N=int(input())
c_list=list(input().split())
mod = 10**9+7

graph=[[] for _ in range(N)]

for _ in range(N-1):
    u,v=map(int,input().split())
    graph[u-1].append(v-1)
    graph[v-1].append(u-1)

visited=[0 for _ in range(N)]
dp=[[0 for _ in range(3)] for _ in range(N)]
"""
dp: 各頂点において、三つの異なる状態を持つ動的計画法のテーブル。
dp[v][0]：頂点 v 以下の部分木で 'a' のみを含む場合の数。
dp[v][1]：頂点 v 以下の部分木で 'b' のみを含む場合の数。
dp[v][2]：頂点 v 以下の部分木で 'a' と 'b' の両方を含む場合の数。
"""


"""
dfs 関数の動作
dfs(v) 関数は頂点 v から始めて、dp テーブルを更新しながら深さ優先探索を行います。

S1 は頂点 v が 'a' の場合は 'a' のみ、'b' の場合は 'b' のみを含む場合の数。
S2 は頂点 v 以下の部分木で 'a' と 'b'と'ab' の組み合わせの数。


「(1)子の連結成分が'a'の状態かつ、連結している」のパターンは明らかにOKである。なぜなら、子の連結成分が'a'の状態で頂点uと連結していれば、頂点uは'a'の状態のままだからである。

「(2)子の連結成分が'ab'の状態かつ、連結していない」のパターンも明らかにOKである。なぜなら、子の連結成分が'ab'の状態なら問題の制約上連結しなくてもOKであり、頂点uは'a'の状態のままだからである。

他のパターンも考えてみる。たとえば、「子の連結成分が'b'の状態かつ、連結していない」パターンはなぜ足しては駄目なのか。これだと「子の連結成分が'b'の状態のまま」になってしまい、これは問題の制約上「どの連結成分も'ab'の状態になっていなければならない」を満たせないからである。
"""
def dfs(v):
    visited[v]=1
    S1 = 1
    S2 = 1
    #S2-S1がaとbを両方持つ組み合わせの数
    for to in graph[v]:
        if visited[to]:
            continue
        dfs(to)
        #自分(v)の部分木をdfsで全探索した後に
        if c_list[v] == 'a':#自分(v)がaなら
            S1 = S1 * (dp[to][0]+dp[to][2]) % mod#S1 は 'a'だけ または 'ab' の組み合わせの総数　
        else:
            S1 = S1 * (dp[to][1]+dp[to][2]) % mod#'b' だけ　または 'ab' の組み合わせの総
        S2 = S2 * (dp[to][0]+dp[to][1]+2*dp[to][2]) % mod#S2 は、'a' 、'b' 、'ab' の組み合わせの総数
        #dp[to][0] と dp[to][1]は必ずどちらかは0になる
    if c_list[v] == 'a':
        dp[v][0] = S1
    else:
        dp[v][1] = S1
    #v==a の時はS1はa or ab, v==bのときはb or abの組み合わせの総数
    dp[v][2] = (S2 - S1) % mod

dfs(0)
print(dp[0][2])


"""
      1a
     / \
    2a  3b
   /|\
 4b 5a 6b

この図で、dfs(1)から探索が始まります。

頂点1に注目すると、この頂点は'a'にラベル付けされています。
したがって、S1の計算では、子ノードの2と3それぞれについて、'a'のみを含む場合と、'a'と'b'の両方を含む場合の数を計算します。
具体的には：

頂点2について
頂点2は'a'にラベル付けされているので、S1は(dp[2][0] + dp[2][2])を含みます。これは、頂点2以下の部分木で、全ての連結成分が'a'のみまたは'a'と'b'の両方を含む場合の数を意味しています。
頂点3について
頂点3は'b'にラベル付けされているが、S1の計算では影響を与えません。これは、頂点1が'a'であり、'a'と同じラベルを含む子ノードの組み合わせのみを考慮するためです。
このように、S1は、ある頂点vが'a'でラベル付けされた場合、v以下の部分木で'a'のみ、または'a'と'b'の両方を含む場合の数を計算しています。同様に、vが'b'でラベル付けされた場合、v以下の部分木で'b'のみ、または'a'と'b'の両方を含む場合の数を計算します。

3bだけだと、問題の条件満たさないから、そこの辺は切れない→だから計算に影響が出ない
"""