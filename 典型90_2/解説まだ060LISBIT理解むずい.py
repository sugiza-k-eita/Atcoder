"""
問題文 長さ N の数列 A=(A 1 ​ ,A 2 ​ ,⋯,A N ​ ) が与えられます。 A の（連続とは限らない）部分列 B=(B 1 ​ ,B 2 ​ ,⋯,B M ​ ) であって、次の条件を満たすものを考えます。 条件　ある整数 K(1≤K≤M) が存在して、以下の条件をともに満たす 1≤j<K を満たす全ての j に対し、 B j ​ <B j+1 ​ が成立する K≤j<M を満たす全ての j に対し、 B j ​ >B j+1 ​ が成立する B の要素数 M として考えられる最大値を求めてください。
"""

class BIT:
    def __init__(self, n):
        self.n = n
        self.bit = [0] * (n + 1)

    def add(self, i, x):
        i += 1  # 1-indexed
        while i <= self.n:
            self.bit[i] = max(self.bit[i], x)
            i += i & -i

    def query(self, i):
        i += 1  # 1-indexed
        res = 0
        while i > 0:
            res = max(res, self.bit[i])
            i -= i & -i
        return res
# LIS

N = int(input())
A = list(map(int, input().split()))

# upの計算
box = []
for i in range(N):
    val = A[i]
    box.append([val, N - i])
box.sort()

up = [0] * N
bit = BIT(N)
for i in range(N):
    ind = N - box[i][1]
    up[ind] = bit.query(ind) + 1
    bit.add(ind, up[ind])

# downの計算
box = []
for i in range(N):
    val = A[i]
    box.append([val, i])
box.sort()

down = [0] * N
bit = BIT(N)
for i in range(N):
    ind = box[i][1]
    down[ind] = bit.query(N - ind - 1) + 1
    bit.add(N - ind - 1, down[ind])

# 最終結果の計算
ans = 0
for u, d in zip(up, down):
    ans = max(ans, u + d - 1)

print(ans)


"""
問題文 
長さ N の数列 A=(A 1 ​ ,A 2 ​ ,⋯,A N ​ ) が与えられます。 A の（連続とは限らない）部分列 B=(B 1 ​ ,B 2 ​ ,⋯,B M ​ ) であって、次の条件を満たすものを考えます。 条件　ある整数 K(1≤K≤M) が存在して、以下の条件をともに満たす 1≤j<K を満たす全ての j に対し、 B j ​ <B j+1 ​ が成立する K≤j<M を満たす全ての j に対し、 B j ​ >B j+1 ​ が成立する B の要素数 M として考えられる最大値を求めてください。


ある点jにおいて
数列 \( A \) のある部分列 \( B \) において、あるインデックス \( K \) が存在し、
- インデックス \( 1 \) から \( K \) までの要素が単調増加し、
- インデックス \( K \) から \( M \) までの要素が単調減少する


すべての点jについて
そのため、(0~j番目の最長増加列+j~N番目の最長減少列-1)が出力すべき値になります。
(jが被っているため、-1)


まずは単調増加について考える。

ex)
ind
0 1 2 3 4 5
1,2,4,3,4,6という点があった時
最長部分増加列は、
1,2,3,5,6となる

ここで重要なのは、ただ左からA[j]よりも小さいのを取得するわけではないということです
(左からA[j]よりも小さいのを取得するだけなら、[1,2,4,6])

ではどうしたら良いか？
基本方針としては、
より小さい数を取得したほうがよい→ちょっとずつ単調増加したほうがいっぱい選べるから
小さい数から探索する際により左側の数を取得したほうがよい→その分右側に大きい数がおけるから

なので、優先順位的には
小さい数から取得する
小さい数から取得した際に、より左側にあるものから取得する
とします。

これにより
ind
0 1 2 3 4 5
1,2,4,3,4,6という点があった時
1. 1を取得
2. 2を取得
3. 3を取得
4. 4番目の4を取得
となり、A[5]まで最大増加列を取得できます。






### コードの解説
#### BIT (Binary Indexed Tree)
このコードはBITを使用しています。BITは、累積和に基づいた高速なデータ構造で、主に、数列の部分和や、部分列の最大値・最小値のクエリを効率よく処理するために使用されます。

#### 解法の全体流れ
1. **Up Calculation:** 
   \( A \) の各要素を、その値とインデックスを逆順にしてソートします。そして、各要素に対して、そのインデックスまでの部分列の最大の単調増加部分列の長さを計算します。
   
2. **Down Calculation:**
   \( A \) の各要素を、その値とインデックスを使ってソートします。そして、各要素に対して、そのインデックスから最後までの部分列の最大の単調減少部分列の長さを計算します。

3. **Final Result Calculation:**
   UpとDownの結果を組み合わせて、求めるべき最大の部分列の長さを計算します。具体的には、各インデックス \( i \) について、`up[i] + down[i] - 1` の最大値を求めます。`-1` するのは、インデックス \( K \) が重複カウントされるためです。

### 各部の詳細
- **Up Calculation**
  - `box`リストに、元の数列の各要素と、そのインデックスを逆順にした組を追加します。
  - `box`をソートし、それを使って、BITを使用しながら、各要素までの最大の単調増加部分列の長さを`up`リストに保存します。

- **Down Calculation**
  - 同様に、`box`リストに、元の数列の各要素とそのインデックスの組を追加します。
  - `box`をソートし、それを使って、BITを使用しながら、各要素から最後までの最大の単調減少部分列の長さを`down`リストに保存します。

- **Final Result Calculation**
  - 最後に、`up`と`down`の各インデックスの要素を合計し、その最大値を求めます。これが求めるべき最大の部分列の長さです。

このアルゴリズムによって、与えられた問題の要件を満たす最大の部分列の長さを効率よく計算することができます。










BIT（Binary Indexed TreeまたはFenwick Tree）のコードを詳しく説明します。このデータ構造は、要素の追加や、範囲にわたるクエリ処理（例：累積和、最大値、最小値の計算など）を効率よく行うことができます。

BITのコード
以下は、BITクラスのコードです。このクラスは二つのメソッドaddとqueryを持っています
各メソッドの説明
__init__(self, n):

nは配列の要素数。
self.bitはBITの配列で、0で初期化されています。1-indexedであるため、n + 1の長さが必要です。
add(self, i, x):

iは更新したい要素のインデックス、xは追加したい値です。
このメソッドは、iの位置にxを加えます。具体的には、このコードでは、iの位置の値とxのうち大きい方をiの位置の値として更新しています。
query(self, i):

iはクエリの上限となるインデックスです。
このメソッドは、インデックス1からインデックスiまでの範囲に対するクエリを計算します。このコードでは、インデックス1からインデックスiまでの最大値を返します。
BITの作動原理
addメソッドでは、指定されたインデックスiから始めて、iのビット表現の最も低いビットの値だけiを増加させながら、対応するbit配列の要素を更新していきます。
queryメソッドでは、指定されたインデックスiから始めて、iのビット表現の最も低いビットの値だけiを減少させながら、対応するbit配列の要素から結果を計算していきます。
このようなメカニズムにより、BITは累積和や範囲にわたるクエリの処理を効率的に行えます。

今回の問題では、数列Aから取りうる部分列Bの中で、昇順に増加していく部分と、それがピークに達した後に減少する部分、の二つが存在します。このピークを中心に左側では昇順に増加し、右側では減少する、という構造になります。問題の要求する答えは、このような構造を持つ部分列Bの最大の長さです。

以下は、この問題を解くためのアプローチです。

1. 前処理
まず、配列Aの各要素について、その要素をピークとした場合の、左側での昇順部分列の最大長を計算します。これをup配列に格納します。
次に、同様に、その要素をピークとした場合の、右側での減少部分列の最大長を計算します。これをdown配列に格納します。
2. BITの利用
各要素について、その要素をピークとした場合のupとdownの長さを求めるのに、BITを使用します。
upの計算では、BITを利用して、左側の要素からその要素までの昇順部分列の最大長を効率よく計算します。
downの計算では、BITを利用して、その要素から右側の要素までの減少部分列の最大長を効率よく計算します。
3. 最終結果の計算
最後に、各要素をピークとした場合の、upとdownの合計長から1を引いたものの最大値を答えとします。1を引くのは、ピークの要素が重複してカウントされるからです。


図解
A: 1 3 5 4 2

up:   1 2 3 1 1
down: 1 1 1 2 3

計算:
1: up[1] + down[1] - 1 = 1
3: up[2] + down[2] - 1 = 2
5: up[3] + down[3] - 1 = 3
4: up[4] + down[4] - 1 = 2
2: up[5] + down[5] - 1 = 3

最大値: 3

"""
