#工夫した全探索、bit全探索

"""
問題文 
縦 H 行、横 W 列のグリッドがあり、上から i 行目、左から j 列目のマスを (i,j) で表します。マス (i,j) には整数 P i,j ​ が書かれています。 さて、このグリッドから（連続するとは限らない） 1 つ以上の行と 1 つ以上の列を選ぶことでできる「部分グリッド」であって、次の条件を満たすものを良い部分グリッドと呼びます。 条件　選んだ行を i 1 ​ ,i 2 ​ ,…,i A ​ (1≤i 1 ​ <i 2 ​ <⋯<i A ​ ≤H) とし、選んだ列を j 1 ​ ,j 2 ​ ,…,j B ​ (1≤j 1 ​ <j 2 ​ <⋯<j B ​ ≤W) とすると、マス (i a ​ ,j b ​ ) (1≤a≤A,1≤b≤B) に書かれている整数はすべて同じである。 良い部分グリッドの大きさとしてあり得る最大値を求めてください。 ただし A 個の行・ B 個の列からなる部分グリッドの大きさは A×B であるとします。
"""
# bit全探索
import itertools

H, W = map(int, input().split())

box = []
for i in range(H):
    P = list(map(int, input().split()))
    box.append(P)

ans = 0

# 行の組み合わせを全探索
for bit in itertools.product([0, 1], repeat=H):
    use_num = [i for i in range(H) if bit[i] == 1]

    # 選択された行がない場合はスキップ
    if not use_num:
        continue

    count = {}
    # 列に関しても同様に全探索
    for j in range(W):
        # 最初の行のj列目の値を取得
        value = box[use_num[0]][j]
        # すべての行でj列目の値が同じかどうかを判定
        if all(box[u][j] == value for u in use_num):
            #選択された各行に対して、各列の数値が一致するかを確認します。一致する場合、その値の出現回数をカウント
            
            #各列で一致した値の出現回数をカウント
            if value not in count:
                count[value] = 1
            else:
                count[value] += 1
    freq_max = 0#最も頻繁に出現した値の回数
    for key in count:
        freq_max = max(freq_max, count[key])

    # 選択した行の数と、すべての値が同じであった列の数を掛け合わせて部分グリッドの大きさを計算
    ans = max(ans, len(use_num) * freq_max)

print(ans)

"""
・盛り込みたい内容
Hが小さいので、Hについてbit探索が行えそう
行の組み合わせについてbit全探索を行い、その中で選択した行の数とすべての値が同じであった列の数の積が部分グリッドの大きさ
2**8 * 10**4 < 10**7より十分に余裕がある

この問題のコードは、行の組み合わせを全探索して、「良い部分グリッド」の最大の大きさを求めています。

### 概要
1. 各行が選択されるかどうかを全探索します。`itertools.product([0, 1], repeat=H)`を使用しています。ここで`H`は行数です。
2. 選択された各行に対して、各列の数値が一致するか確認します。
3. 各列で一致した数値に対し、その数値が出現する回数をカウントします。
4. カウントした出現回数と、選択した行数を掛け合わせ、これまでの最大値と比較・更新します。

### 詳細な手順
以下はコードの詳細な手順です。

#### 1. 行の全探索
```python
for bit in itertools.product([0, 1], repeat=H):
    use_num = [i for i in range(H) if bit[i] == 1]
```
この部分で、行の全ての組み合わせをbit全探索しています。`use_num`には選択された行のインデックスが格納されます。

#### 2. 選択された行での列の確認
```python
for j in range(W):
    value = box[use_num[0]][j]
    if all(box[u][j] == value for u in use_num):
```
選択された各行に対して、各列の数値が一致するかを確認します。一致する場合、その値の出現回数をカウントします。

#### 3. 出現回数のカウント
```python
if value not in count:
    count[value] = 1
else:
    count[value] += 1
```
各列で一致した値の出現回数をカウントしています。

#### 4. 最大部分グリッドの大きさの計算
```python
freq_max = max(count.values(), default=0)
ans = max(ans, len(use_num) * freq_max)
```
最後に、これまでにカウントした中で最も頻繁に出現した値の回数`freq_max`と、選択した行の数`len(use_num)`を掛け合わせて、最大の部分グリッドの大きさを計算します。

このコードによって、条件を満たす「良い部分グリッド」の最大の大きさを効率良く計算することができます。


この問題の例では、`4x6`のグリッドが与えられています。以下に、各行の組み合わせを全探索して、「良い部分グリッド」の最大の大きさを図示して説明します。

### グリッドの初期状態
```
1 1 1 1 1 2
1 2 2 2 2 2
1 2 2 3 2 3
1 2 3 2 2 3
```

### 処理の流れ
1. **第1行**の組み合わせを探索（例：1行目のみ、1行目と2行目、1行目と3行目、1行目と4行目など）
2. 同様に、**第2行、第3行、第4行**の組み合わせも探索。
3. 各組み合わせに対して、列方向に同じ値が存在するか探索。
4. 同じ値が存在する列の数と、選択された行の数を掛けて最大値を更新。

### 例：部分組み合わせの探索
以下は、特定の行の組み合わせでの探索例です。

#### 1行目と2行目を選択
```
1 1 1 1 1 2
1 2 2 2 2 2
```
この場合、第1列と第2列で値が一致しますので、良い部分グリッドの大きさは `2列 * 2行 = 4` となります。

#### 1行目と3行目を選択
```
1 1 1 1 1 2
1 2 2 3 2 3
```

例でいうと、特定の行の組み合わせで、それぞれの列において同じ値が存在するか探索します。具体的には、選択された行の中で、各列が同じ値を持つかどうかを見ていきます。

#### 例：1行目と2行目を選択した場合

選択されたグリッド：
```
1 1 1 1 1 2
1 2 2 2 2 2
```

この場合、以下のように列ごとに検証します。
1. **第1列：** `1` と `1` → 一致
2. **第2列：** `1` と `2` → 不一致
3. **第3列：** `1` と `2` → 不一致
4. **第4列：** `1` と `2` → 不一致
5. **第5列：** `1` と `2` → 不一致
6. **第6列：** `2` と `2` → 一致

したがって、1行目と2行目を選択した場合、1列目と6列目でのみ値が一致しましたので、「良い部分グリッド」の大きさは `2（列） * 2（行） = 4` となります。

同様に、全ての行の組み合わせについて、このプロセスを繰り返し、同じ値が存在する列の数をカウントします。その後、選択された行の数と同じ値が存在する列の数を掛け合わせて、それが現在の最大値より大きければ最大値を更新します。

このプロセスを全ての組み合わせで行い、最終的に得られた最大値が「良い部分グリッド」の最大の大きさとなります。



### 最終結果
これを全ての組み合わせで繰り返し、最大の「良い部分グリッド」の大きさを求めます。この例では、「2x3」の部分グリッドが最大となり、その大きさは `6` です。

```
2 2 2
2 2 2
```
"""